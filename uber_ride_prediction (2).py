# -*- coding: utf-8 -*-
"""Uber_Ride_Prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JW0WMUpcHiyi9It5LGIhRZWOwivAOyUi

**Learn from Dataset:**

‚è±Ô∏è'trip_duration': Duration of the travel in [seconds]

üõ£Ô∏è 'distance_traveled': How many kilometers the taxi has covered?

üßë‚Äçü§ù‚Äçüßë 'num_of_passengers': How many passengers were in the taxi?

üíµ 'fare': What is the base fare for the journey?[In INR]

üí≤ 'tip': How much did the driver receive in tips?[In INR]

üí∞ 'total_fare': The amount of money paid for the journey (this is your prediction target!).[In INR]

‚ö° 'surge_applied': Was there a surge pricing applied? Yes or no?

**Import Libraries**
"""

# Commented out IPython magic to ensure Python compatibility.
from scipy import stats
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
# %matplotlib inline
import seaborn as sns
import warnings
warnings.filterwarnings("ignore")

from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score, mean_absolute_error, mean_squared_error
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.ensemble import RandomForestRegressor
import xgboost as xgb
from sklearn.metrics import confusion_matrix

"""**Loading Uber DataSet**"""

data=pd.read_csv('https://raw.githubusercontent.com/keshaditi/MLdatasets/refs/heads/main/UberDataset.csv')

data.head(3)

"""**Exploratory Data Analysis**"""

data.info()

data.shape

data.nunique()

data.columns

data.isnull().sum()

data.dropna(inplace=True)

data.duplicated().sum()

data.shape

data.describe(include='all')

data.dropna(how='any')

data = data.drop('num_of_passengers', axis=1)

data.dtypes

data.describe()

data.head(3)

data['trip_duration'].describe()

data.head(2)

"""**Data Visualization**

**Univarient Analysis**
"""

sns.histplot(data['trip_duration'])
plt.title('Trip Duration (secs) Distribution')
plt.xlabel('Seconds')
plt.ylabel('Count')
plt.show()

numerical_features = ['trip_duration', 'distance_traveled', 'fare', 'tip', 'total_fare','miscellaneous_fees']

fig, axes = plt.subplots(1, len(numerical_features), figsize=(20, 5))  # 1 row, n columns

for i, feature in enumerate(numerical_features):
    sns.histplot(data[feature], kde=True, ax=axes[i])  # kde=True adds a kernel density estimate curve
    axes[i].set_title(f'Distribution of {feature}')
    axes[i].set_xlabel(feature)
    axes[i].set_ylabel('Frequency')

plt.tight_layout()  # Adjusts subplot params for a tight layout
plt.show()

# Create a bar plot for Surge Applied
plt.figure(figsize=(4, 3))  # Adjust figure size if needed
ax = sns.countplot(x='surge_applied', data=data)
plt.title('Distribution of Surge Applied')
plt.xlabel('Surge Applied')
plt.ylabel('Count')

# Add count labels on top of bars
for p in ax.patches:
    ax.annotate(f'{p.get_height()}', (p.get_x() + p.get_width() / 2., p.get_height()),
                ha='center', va='center', xytext=(0, 10), textcoords='offset points')

plt.show()

#Scatter Plot on basis of Total Fare and Features
numerical_features = ['trip_duration', 'distance_traveled', 'fare', 'tip', 'miscellaneous_fees']

fig, axes = plt.subplots(2, 3, figsize=(15, 10))  # 2 rows, 3 columns
axes = axes.flatten()

# Loop through numerical features and create scatter plots
for i, feature in enumerate(numerical_features):
    sns.scatterplot(x=feature, y='total_fare', data=data, ax=axes[i])
    axes[i].set_title(f'Scatter Plot of {feature} vs. Total Fare')
    axes[i].set_xlabel(feature)
    axes[i].set_ylabel('Total Fare')

plt.tight_layout()
plt.show()

#Box plot to find outliers
numerical_features = ['trip_duration', 'distance_traveled', 'fare', 'tip', 'total_fare', 'miscellaneous_fees']
fig, axes = plt.subplots(1, len(numerical_features), figsize=(20, 6))  # 1 row, n columns

# Loop through features and create box plots on subplots
for i, feature in enumerate(numerical_features):
    sns.boxplot(x=data[feature], ax=axes[i])
    axes[i].set_title(f'Box Plot of {feature}')
    axes[i].set_xlabel(feature)

plt.tight_layout()
plt.show()

#Removing outliers
numerical_features = ['trip_duration', 'distance_traveled',  'fare', 'tip', 'total_fare','miscellaneous_fees']

for feature in numerical_features:
    z = np.abs(stats.zscore(data[feature]))

    # Filter data for the current feature
    data = data[(z < 3)]  # Threshold of 3 for outliers

#After Outlier dataset
numerical_features = ['trip_duration', 'distance_traveled',  'fare', 'tip', 'total_fare','miscellaneous_fees']
fig, axes = plt.subplots(1, len(numerical_features), figsize=(20, 6))  # 1 row, n columns
# Loop through features and create box plots on subplots
for i, feature in enumerate(numerical_features):
  sns.boxplot(x=data[feature], ax=axes[i])
  axes[i].set_title(f'Box Plot of {feature} (After Outlier Removal)')
  axes[i].set_xlabel(feature)
plt.tight_layout()
plt.show()

#Correlation Matrix
correlation_matrix = data.corr()

# Display the correlation matrix using a heatmap
plt.figure(figsize=(12, 10))  # Adjust figure size if needed
sns.heatmap(correlation_matrix, annot=True, cmap='viridis', fmt=".2f")
plt.title('Correlation Matrix of Numerical Features')
plt.show()

"""**Train & Test Dataset**"""

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score, mean_absolute_error, mean_squared_error

X=data.drop(['total_fare'],axis=1)
y=data['total_fare']

X.head(3)

y

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=30)

"""**Model Selection**"""

# Linear Regression
LR = LinearRegression()
LR.fit(X_train, y_train)

# Random Forest
RF = RandomForestRegressor(random_state=30)
RF.fit(X_train, y_train)

# XGBoost
XGB = xgb.XGBRegressor(random_state=30)
XGB.fit(X_train, y_train)

#Make prediction and evaluate
models = [LR, RF, XGB]
model_names = ['Linear Regression', 'Random Forest', 'XGBoost']

for model, name in zip(models, model_names):
    y_pred = model.predict(X_test)

    r2 = r2_score(y_test, y_pred)
    mse = mean_squared_error(y_test, y_pred)
    mae = mean_absolute_error(y_test, y_pred)

    print(f"Model: {name}")
    print(f"R-squared: {r2:.4f}")
    print(f"Mean Squared Error: {mse:.4f}")
    print(f"Mean Absolute Error: {mae:.4f}")
    print("-" * 20)

# Make predictions
y_pred_LR = LR.predict(X_test)
y_pred_RF = RF.predict(X_test)
y_pred_XGB = XGB.predict(X_test)

# Calculate R2 scores
r2_LR = r2_score(y_test, y_pred_LR)
r2_RF = r2_score(y_test, y_pred_RF)
r2_XGB = r2_score(y_test, y_pred_XGB)

# Find the best model
best_model = max([(r2_LR, 'Linear Regression'), (r2_RF, 'Random Forest'), (r2_XGB, 'XGBoost')])[1]

print(f"The best model based on R2 score is: {best_model}")

scaler = StandardScaler()
X_train_SD = scaler.fit_transform(X_train)

"""**Model Building**"""

LR = LinearRegression()
LR.fit(X_train_SD, y_train)

print("Mean Square Error:", mean_squared_error(y_test, y_pred))
print("Mean Absolute Error:", mean_absolute_error(y_test, y_pred))

accuracy = r2_score(y_test, y_pred)
print("Accuracy:", accuracy)

LR.score(X_train_SD,y_train)

LR.score(X_test,y_test)

plt.scatter(y_test, y_pred)
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'r--')
plt.xlabel('Actual Charges')
plt.ylabel('Predicted Charges')
plt.title('Linear Regression - Actual vs. Predicted Charges')
plt.show()

# Coefficient and Intercept
print("Intercept:",LR.intercept_)
print("\n")
print("Coefficient(s):", LR.coef_)

"""**Confusion Matrix**"""

y_pred = LR.predict(X_test)
data['fare_category'] = pd.qcut(data['total_fare'], 3, labels=['low', 'medium', 'high'])
y_pred_cat = pd.qcut(y_pred, 3, labels=['low', 'medium', 'high'])

# Discretize y_test to create y_test_cat (New line)
y_test_cat = pd.qcut(y_test, 3, labels=['low', 'medium', 'high'])

# 5. Create the confusion matrix
cm = confusion_matrix(y_test_cat, y_pred_cat, labels=['low', 'medium', 'high'])

# 6. Plot the confusion matrix
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues',
            xticklabels=['low', 'medium', 'high'],
            yticklabels=['low', 'medium', 'high'])
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.title('Confusion Matrix for Linear Regression')
plt.show()

"""**PREDICTION**"""

LR.predict([[20, 2.7, 5,4,3,1]])

pip install streamlit

import streamlit as st
import pandas as pd
import numpy as np
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler

# Load the trained model from your notebook (LR in this case)
# You might need to save and load it if it's not already persistent
# For example, using pickle:
# import pickle
# with open('linear_regression_model.pkl', 'rb') as f:
#     LR = pickle.load(f)

# ... or using joblib:
# import joblib
# LR = joblib.load('linear_regression_model.joblib')

# Create a title for the Streamlit app
st.title('Uber Fare Prediction')

# Create input fields for the features
trip_duration = st.number_input('Trip Duration (seconds)', min_value=0, step=1)  # Step=1 for integers
distance_traveled = st.number_input('Distance Traveled (km)', min_value=0, step=1)  # Step=1 for integers
fare = st.number_input('Base Fare (INR)', min_value=0, step=1)  # Step=1 for integers
tip = st.number_input('Tip (INR)', min_value=0, step=1)  # Step=1 for integers
miscellaneous_fees = st.number_input('Miscellaneous Fees (INR)', min_value=0, step=1)  # Step=1 for integers
surge_applied = st.selectbox('Surge Applied', ['No', 'Yes'])

# Convert surge_applied to numerical (0 for No, 1 for Yes)
surge_applied_num = 1 if surge_applied == 'Yes' else 0

# Create a button to trigger prediction
if st.button('Predict Fare'):
    # Create input data as a DataFrame
    input_data = pd.DataFrame({
        'trip_duration': [trip_duration],
        'distance_traveled': [distance_traveled],
        'fare': [fare],
        'tip': [tip],
        'miscellaneous_fees': [miscellaneous_fees],
        'surge_applied': [surge_applied_num]
    })

    # Scale the input data using the same scaler used during training
    input_data_scaled = scaler.transform(input_data)

    # Make prediction
    prediction = LR.predict(input_data_scaled)[0]

    # Display prediction
    st.success(f'Predicted Total Fare: INR {prediction:.2f}')

